//day 2 of working on this
i've figured out the graph, kind of
I just have to figure out how to display it like an adjacencyList

I tried writing out the paths by hand, but i genuinely didn't get to the right balloon.
im going to use paths.js to generate the object balloon and do the math for the paths


//day 3

here is the hierarchy
  Main
  manager
  Paths
  graph


main will have the original balloon, which will be passed to manager
manager will set up the path generator in paths, which is responsible for creating new balloons
and moves

paths will take the original balloon, modify it, create new balloons, push it to the the list that it needs to be in
and manager will check if the final balloon has been found,
each pass will modify a different balloon, until the final balloon has been found

once that it has been found, manager will stop making passes and paths will call DFS in graphs, and it will display
the fastest way to get to the balloon that we need to get to.


//what i could do for printing
set up first row,
call run()
++ a counter that changes the row
call run()
rinse, repeat

run would be the one printing the row to the screen


// this code for a graph, and its traversal was found at
// https://www.freecodecamp.org/news/8-essential-graph-algorithms-in-javascript/
// i am reusing and modifying the source code to fit this applicaiton
class Graph {
  constructor(){
    this.adjacencyList = {};
    var twoD = new Array();
  }
  addVertex(vertex){
    if(!this.adjacencyList[vertex]){
      this.adjacencyList[vertex] = [];
    }
  }
  addEdge(source, destination){
    console.log("adding edge");
    console.log("source:");
    console.log(source);
    console.log("destination:");
    console.log(destination);
    if(!this.adjacencyList[source]){
      this.addVertex(source);
    }
    //if(!this.adjacencyList[destination]){
    //  this.addVertex(destination);
  //  }
    this.adjacencyList[source].push(destination);
  //  this.adjacencyList[destination].push(source);

  }
  print(){
    console.log(this.adjacencyList[source].destination);
  }
  dfs(start){
    console.log("dfs");
    console.log(Object.keys(this.adjacencyList).length);
    for(let i = 0; i < this.adjacencyList.length; i++){
      console.log("loop");
      for(let j = 0; i < this.adjacencyList[i].length; j++);
      console.log("loop");
      console.log(this.adjacencyList[i].j)
    }
    const result = [];
    const stack = [start];
    const visited = {};
    visited[start] = true;
    let currentVertex;
    while (stack.length) {
      currentVertex = stack.pop();
      result.push(currentVertex);
      this.adjacencyList[currentVertex].forEach(neighbor => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          stack.push(neighbor);
          console.log(neighbor);
        }
      });
    }
    //console.log(result);
    return result;
    }
  }
